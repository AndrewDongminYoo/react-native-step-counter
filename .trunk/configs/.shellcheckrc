enable=all
source-path=SCRIPTDIR

# disable=SC1000  # $ is not used specially and should therefore be escaped.
# disable=SC1001  # This `\o` will be a regular 'o' in this context.
# disable=SC1003  # Want to escape a single quote? echo 'This is how it'\\''s done'.
# disable=SC1004  # This backslash+linefeed is literal. Break outside single quotes if you just want to break the line.
# disable=SC1007  # Remove space after = if trying to assign a value (or for empty string, use var='' ... ).
# disable=SC1008  # This shebang was unrecognized. ShellCheck only supports sh/bash/dash/ksh. Add a 'shell' directive to specify.
# disable=SC1009  # The mentioned parser error was in ...
# disable=SC1010  # Use semicolon or linefeed before 'done' (or quote to make it literal).
# disable=SC1011  # This apostrophe terminated the single quoted string!
# disable=SC1012  # `\t` is just literal `t` here. For tab, use `"$(printf '\t')"` instead.
# disable=SC1014  # Use 'if cmd; then ..' to check exit code, or 'if [ "$(cmd)" = .. ]' to check output.
# disable=SC1015  # This is a unicode double quote. Delete and retype it.
# disable=SC1016  # This is a Unicode single quote. Delete and retype it.
# disable=SC1017  # Literal carriage return. Run script through `tr -d '\r'` .
# disable=SC1018  # This is a unicode non-breaking space. Delete it and retype as space.
# disable=SC1019  # Expected this to be an argument to the unary condition.
# disable=SC1020  # You need a space before the if single then "]" else "]]"
# disable=SC1026  # If grouping expressions inside [[..]], use ( .. ).
# disable=SC1027  # New page
# disable=SC1028  # In [..] you have to escape \\( \\) or preferably combine [..] expressions.
# disable=SC1029  # In `[[..]]` you shouldn't escape `(` or `)`.
# disable=SC1035  # You need a space here
# disable=SC1036  # `(` is invalid here. Did you forget to escape it?
# disable=SC1037  # Braces are required for positionals over 9, e.g. ${10}.
# disable=SC1038  # Shells are space sensitive. Use '< <(cmd)', not '<<(cmd)'.
# disable=SC1039  # Remove indentation before end token (or use `<<-` and indent with tabs).
# disable=SC1040  # When using <<-, you can only indent with tabs.
# disable=SC1041  # Found 'eof' further down, but not on a separate line.
# disable=SC1042  # Found 'eof' further down, but not on a separate line.
# disable=SC1044  # Couldn't find end token `EOF' in the here document.
# disable=SC1045  # It's not 'foo &; bar', just 'foo & bar'.
# disable=SC1046  # Couldn't find 'fi' for this 'if'.
# disable=SC1047  # "Expected 'fi' matching previously mentioned 'if'.
# disable=SC1048  # Can't have empty then clauses (use 'true' as a no-op).
# disable=SC1049  # Did you forget the 'then' for this 'if'?
# disable=SC1050  # Expected 'then'.
# disable=SC1051  # Semicolons directly after 'then' are not allowed. Just remove it.
# disable=SC1052  # Semicolons directly after 'then' are not allowed. Just remove it.
# disable=SC1053  # Semicolons directly after 'else' are not allowed. Just remove it.
# disable=SC1054  # You need a space after the '{'.
# disable=SC1058  # Expected `do`.
# disable=SC1061  # Couldn't find 'done' for this 'do'.
# disable=SC1062  # Expected 'done' matching previously mentioned 'do'.
# disable=SC1064  # Expected a { to open the function definition.
# disable=SC1065  # Trying to declare parameters? Don't. Use () and refer to params as $1, $2..
# disable=SC1066  # Don't use $ on the left side of assignments.
# disable=SC1067  # For indirection, use arrays, `declare "var$n=value"`, or (for sh) read/eval
# disable=SC1068  # Don't put spaces around the = in assignments.
# disable=SC1069  # You need a space before the [.
# disable=SC1070  # Parsing stopped here. Mismatched keywords or invalid parentheses?
# disable=SC1071  # ShellCheck only supports sh/bash/dash/ksh scripts. Sorry!
# disable=SC1072  # Unexpected ..
# disable=SC1073  # Couldn't parse this (thing). Fix to allow more checks.
# disable=SC1075  # Use 'elif' instead of 'else if'.
# disable=SC1077  # For command expansion, the tick should slant left (` vs Â´).
# disable=SC1078  # Did you forget to close this double quoted string?
# disable=SC1079  # This is actually an end quote, but due to next char it looks suspect.
# disable=SC1081  # Scripts are case sensitive. Use 'if', not 'If'.
# disable=SC1082  # This file has a UTF-8 BOM. Remove it with: LC_CTYPE=C sed '1s/^...//' < yourscript .
# disable=SC1083  # This `{`/`}` is literal. Check expression (missing `;/\n?`) or quote it.
# disable=SC1084  # Use #!, not !#, for the shebang.
# disable=SC1086  # Don't use $ on the iterator name in for loops.
# disable=SC1087  # "Use braces when expanding arrays, e.g. ${array[idx]} (or ${var}[.. to quiet)."
# disable=SC1088  # Parsing stopped here. Invalid use of parentheses?
# disable=SC1089  # Parsing stopped here. Is this keyword correctly matched up?
# disable=SC1090  # Can't follow non-constant source. Use a directive to specify location.
disable=SC1091  # Not following: (error message here)
# disable=SC1094  # Parsing of sourced file failed. Ignoring it.
# disable=SC1095  # You need a space or linefeed between the function name and body.
# disable=SC1097  # Unexpected ==. For assignment, use =. For comparison, use [/[[.
# disable=SC1098  # Quote/escape special characters when using eval, e.g. eval "a=(b)".
# disable=SC1099  # You need a space before the #.
# disable=SC1100  # This is a unicode dash. Delete and retype as ASCII minus.
# disable=SC1101  # Delete trailing spaces after \ to break line (or use quotes for literal space).
# disable=SC1102  # Shells disambiguate `$((` differently or not at all. For `$(command substition)`, add space after `$(` . For `$((arithmetics))`, fix parsing errors.
# disable=SC1104  # Use #!, not just !, for the shebang.
# disable=SC1105  # Shells disambiguate (( differently or not at all. If the first ( should start a subshell, add a space after it.
# disable=SC1107  # This directive is unknown. It will be ignored.
# disable=SC1108  # You need a space before and after the = .
# disable=SC1109  # This is an unquoted HTML entity. Replace with corresponding character.
# disable=SC1110  # This is a unicode quote. Delete and retype it (or quote to make literal).
# disable=SC1111  # This is a unicode quote. Delete and retype it (or ignore/singlequote for literal).
# disable=SC1112  # This is a unicode quote. Delete and retype it (or ignore/doublequote for literal).
# disable=SC1113  # Use #!, not just #, for the shebang.
# disable=SC1114  # Remove leading spaces before the shebang.
# disable=SC1115  # Remove spaces between # and ! in the shebang.
# disable=SC1116  # Missing $ on a $((..)) expression? (or use ( ( for arrays).
# disable=SC1117  # Backslash is literal in `"\n"`. Prefer explicit escaping: `"\\n"`.
# disable=SC1118  # Delete whitespace after the here-doc end token.
# disable=SC1119  # Add a linefeed between end token and terminating ')'.
# disable=SC1120  # No comments allowed after here-doc token. Comment the next line instead.
# disable=SC1121  # Add ;/& terminators (and other syntax) on the line with the <<, not here.
# disable=SC1122  # Nothing allowed after end token. To continue a command, put it on the line with the `<<`.
# disable=SC1123  # ShellCheck directives are only valid in front of complete compound commands, like `if`, not e.g. individual `elif` branches.
# disable=SC1124  # ShellCheck directives are only valid in front of complete commands like 'case' statements, not individual case branches.
# disable=SC1125  # Invalid key=value pair in directive
# disable=SC1126  # Place shellcheck directives before commands, not after.
# disable=SC1127  # Was this intended as a comment? Use `#` in sh.
# disable=SC1128  # The shebang must be on the first line. Delete blanks and move comments.
# disable=SC1129  # You need a space before the !.
# disable=SC1130  # You need a space before the :.
# disable=SC1131  # Use `elif` to start another branch.
# disable=SC1132  # This `&` terminates the command. Escape it or add space after `&` to silence.
# disable=SC1133  # Unexpected start of line. If breaking lines, |/||/&& should be at the end of the previous one.
# disable=SC1135  # Prefer escape over ending quote to make `$` literal. Instead of `"It costs $"5`, use `"It costs \$5"`
# disable=SC1136  # Unexpected characters after terminating `]`. Missing semicolon/linefeed?
# disable=SC2000  # See if you can use ${#variable} instead
# disable=SC2001  # SC2001: See if you can use ${variable//search/replace} instead.
# disable=SC2002  # Useless cat. Consider 'cmd < file | ..' or 'cmd file | ..' instead.
# disable=SC2003  # expr is antiquated. Consider rewriting this using $((..)), ${} or \[\[ \]\].
# disable=SC2004  # $/${} is unnecessary on arithmetic variables.
# disable=SC2005  # Useless `echo`? Instead of `echo $(cmd)`, just use `cmd`
# disable=SC2006  # Use `$(...)` notation instead of legacy backticked `` `...` ``.
# disable=SC2007  # Use $((..)) instead of deprecated $[..]
# disable=SC2008  # echo doesn't read from stdin, are you sure you should be piping to it?
# disable=SC2009  # SC2009 Consider using pgrep instead of grepping ps output.
# disable=SC2010  # Don't use ls | grep. Use a glob or a for loop with a condition to allow non-alphanumeric filenames.
# disable=SC2011  # Use `find -print0` or `find -exec` to better handle non-alphanumeric filenames.
# disable=SC2012  # Use `find` instead of `ls` to better handle non-alphanumeric filenames.
# disable=SC2013  # To read lines rather than words, pipe/redirect to a 'while read' loop.
# disable=SC2014  # This will expand once before find runs, not per file found.
# disable=SC2015  # Note that A && B || C is not if-then-else. C may run when A is true.
# disable=SC2016  # Expressions don't expand in single quotes, use double quotes for that.
# disable=SC2017  # Increase precision by replacing a/b\*c with a\*c/b.
# disable=SC2018  # Use '[:lower:]' to support accents and foreign alphabets.
# disable=SC2019  # Use '[:upper:]' to support accents and foreign alphabets.
# disable=SC2020  # tr replaces sets of chars, not words (mentioned due to duplicates).
# disable=SC2021  # Don't use [] around ranges in tr, it replaces literal square brackets.
# disable=SC2022  # Note that unlike globs, o* here matches 'ooo' but not 'oscar'
# disable=SC2024  # `sudo` doesn't affect redirects. Use `..| sudo tee file`
# disable=SC2025  # Make sure all escape sequences are enclosed in `\[..\]` to prevent line wrapping issues
# disable=SC2026  # This word is outside of quotes. Did you intend to `'nest '"'single quotes'"'` instead'?
# disable=SC2027  # The surrounding quotes actually unquote this. Remove or escape them.
# disable=SC2028  # echo won't expand escape sequences. Consider printf.
# disable=SC2029  # Note that, unescaped, this expands on the client side.
# disable=SC2030  # Modification of var is local (to subshell caused by pipeline).
# disable=SC2031  # var was modified in a subshell. That change might be lost.
# disable=SC2032  # Use own script or sh -c '..' to run this from su.
# disable=SC2033  # Shell functions can't be passed to external commands.
disable=SC2034  # foo appears unused. Verify it or export it.
# disable=SC2035  # Use ./\*glob* or -- \*glob* so names with dashes won't become options.
# disable=SC2036  # If you wanted to assign the output of the pipeline, use a=$(b | c) .
# disable=SC2037  # To assign the output of a command, use var=$(cmd) .
# disable=SC2038  # Use -print0/-0 or find -exec + to allow for non-alphanumeric filenames.
# disable=SC2039  # In POSIX sh, *something* is undefined.
# disable=SC2040  # !/bin/sh was specified, so ____ is not supported, even when sh is actually bash.
# disable=SC2041  # This is a literal string. To run as a command, use $(..) instead of '..' .
# disable=SC2043  # This loop will only ever run once for a constant value. Did you perhaps mean to loop over dir/*, $var or $(cmd)?"
# disable=SC2044  # For loops over find output are fragile. Use find -exec or a while read loop.
# disable=SC2045  # Iterating over ls output is fragile. Use globs.
# disable=SC2046  # Quote this to prevent word splitting
# disable=SC2048  # Use "$@" (with quotes) to prevent whitespace problems.
# disable=SC2049  # =~ is for regex, but this looks like a glob. Use = instead.
# disable=SC2050  # This expression is constant. Did you forget the `$` on a variable?
# disable=SC2051  # Bash doesn't support variables in brace range expansions.
# disable=SC2053  # Quote the rhs of = in [[ ]] to prevent glob matching.
# disable=SC2054  # Use spaces, not commas, to separate array elements.
# disable=SC2055  # You probably wanted && here, otherwise it's always true.
# disable=SC2056  # You probably wanted && here
# disable=SC2057  # Unknown binary operator.
# disable=SC2058  # Unknown unaryoperator.
# disable=SC2059  # Don't use variables in the printf format string. Use printf "..%s.." "$foo".
# disable=SC2060  # Quote parameters to tr to prevent glob expansion.
# disable=SC2061  # Quote the parameter to -name so the shell won't interpret it.
# disable=SC2062  # Quote the grep pattern so the shell won't interpret it.
# disable=SC2063  # Grep uses regex, but this looks like a glob.
# disable=SC2064  # Use single quotes, otherwise this expands now rather than when signalled.
# disable=SC2065  # This is interpreted as a shell file redirection, not a comparison.
# disable=SC2066  # Since you double quoted this, it will not word split, and the loop will only run once.
# disable=SC2067  # Missing ';' or + terminating -exec. You can't use |/||/&&, and ';' has to be a separate, quoted argument.
# disable=SC2068  # Double quote array expansions to avoid re-splitting elements.
# disable=SC2069  # To redirect stdout+stderr, 2>&1 must be last (or use '{ cmd > file; } 2>&1' to clarify).
# disable=SC2070  # `-n` doesn't work with unquoted arguments. Quote or use ``[[ ]]``.
# disable=SC2071  # > is for string comparisons. Use -gt instead.
# disable=SC2072  # Decimals are not supported. Either use integers only, or use bc or awk to compare.
# disable=SC2073  # Escape `\<` to prevent it redirecting (or switch to `[[ .. ]]`).
# disable=SC2074  # Can't use `=~` in `[ ]`. Use `[[..]]` instead.
# disable=SC2076  # Don't quote rhs of =~, it'll match literally rather than as a regex.
# disable=SC2077  # You need spaces around the comparison operator.
# disable=SC2078  # This expression is constant. Did you forget a `$` somewhere?
# disable=SC2079  # (( )) doesn't support decimals. Use bc or awk.
# disable=SC2080  # Numbers with leading 0 are considered octal.
# disable=SC2081  # `[ .. ]` can't match globs. Use `[[ .. ]]` or grep.
# disable=SC2082  # To expand via indirection, use name="foo$n"; echo "${!name}".
# disable=SC2084  # Remove '$' or use '_=$((expr))' to avoid executing output.
# disable=SC2086  # Double quote to prevent globbing and word splitting.
# disable=SC2087  # Quote 'EOF' to make here document expansions happen on the server side rather than on the client.
# disable=SC2088  # Tilde does not expand in quotes. Use $HOME.
# disable=SC2089  # Quotes/backslashes will be treated literally. Use an array.
# disable=SC2090  # Quotes/backslashes in this variable will not be respected.
# disable=SC2091  # Remove surrounding $() to avoid executing output.
# disable=SC2092  # Remove backticks to avoid executing output.
# disable=SC2093  # Remove "exec " if script should continue after this command.
# disable=SC2094  # SC2094 Make sure not to read and write the same file in the same pipeline.
# disable=SC2095  # Use ssh -n to prevent ssh from swallowing stdin.
# disable=SC2096  # On most OS, shebangs can only specify a single parameter.
# disable=SC2097  # This assignment is only seen by the forked process.
# disable=SC2098  # This expansion will not see the mentioned assignment.
# disable=SC2099  # Use `$((..))` for arithmetics, e.g. `i=$((i + 2))`
# disable=SC2100  # Use `$((..))` for arithmetics, e.g. `i=$((i + 2))`
# disable=SC2101  # Named class needs outer [], e.g. [[:digit:]\].
# disable=SC2102  # Ranges can only match single chars (mentioned due to duplicates).
# disable=SC2103  # Use a ( subshell ) to avoid having to cd back.
# disable=SC2104  # In functions, use return instead of break.
# disable=SC2105  # `break` is only valid in loops
# disable=SC2106  # SC2106: This only exits the subshell caused by the pipeline.
# disable=SC2107  # Instead of [ a && b ], use [ a ] && [ b ].
# disable=SC2108  # In [\[..]], use && instead of -a.
# disable=SC2109  # Instead of [ a || b ], use [ a ] || [ b ].
# disable=SC2110  # In [\[..]], use || instead of -o.
# disable=SC2112  # 'function' keyword is non-standard. Delete it.
# disable=SC2114  # Warning: deletes a system directory. 
# disable=SC2115  # Use "${var:?}" to ensure this never expands to /* .
# disable=SC2116  # SC2116 Useless echo? Instead of 'cmd $(echo foo)', just use 'cmd foo'.
# disable=SC2117  # To run commands as another user, use su -c or sudo.
# disable=SC2119  # Use foo "$@" if function's $1 should mean script's $1.
# disable=SC2120  # foo references arguments, but none are ever passed.
# disable=SC2121  # To assign a variable, use just 'var=value', no 'set ..'.
# disable=SC2122  # >= is not a valid operator. Use '! a < b' instead.
# disable=SC2123  # PATH is the shell search path. Use another name.
# disable=SC2124  # Assigning an array to a string! Assign as array, or use * instead of @ to concatenate.
# disable=SC2125  # Brace expansions and globs are literal in assignments. Quote it or use an array.
# disable=SC2126  # Consider using `grep -c` instead of `grep | wc`
# disable=SC2128  # Expanding an array without an index only gives the first element.
# disable=SC2129  # Consider using { cmd1; cmd2; } >> file instead of individual redirects.
# disable=SC2130  # -eq is for integer comparisons. Use = instead.
# disable=SC2139  # This expands when defined, not when used. Consider escaping.
# disable=SC2140  # Word is on the form "A"B"C" (B indicated). Did you mean "ABC" or "A\\"B\\"C"?
# disable=SC2141  # Did you mean IFS=$'\t' ?
# disable=SC2142  # Aliases can't use positional parameters. Use a function.
# disable=SC2143  # Use grep -q instead of comparing output with [ -n .. ].
# disable=SC2144  # -e doesn't work with globs. Use a for loop.
# disable=SC2145  # Argument mixes string and array. Use * or separate argument.
# disable=SC2146  # This action ignores everything before the -o. Use \\( \\) to group.
# disable=SC2147  # Literal tilde in PATH works poorly across programs.
# disable=SC2148  # Add a shebang line to the top of your script:
# disable=SC2149  # Remove $/${} for numeric index, or escape it for string.
# disable=SC2150  # -exec does not automatically invoke a shell. Use -exec sh -c .. for that.
# disable=SC2151  # Only one integer 0-255 can be returned. Use stdout for other data.
# disable=SC2152  # Can only return 0-255. Other data should be written to stdout.
# disable=SC2153  # Possible Misspelling: MYVARIABLE may not be assigned, but MY_VARIABLE is.
disable=SC2154  # var is referenced but not assigned.
disable=SC2155  # Declare and assign separately to avoid masking return values.
# disable=SC2156  # Injecting filenames is fragile and insecure. Use parameters.
# disable=SC2157  # Argument to implicit -n is always true due to literal strings.
# disable=SC2158  # [ false ] is true. Remove the brackets
# disable=SC2159  # [ 0 ] is true. Use 'false' instead
# disable=SC2160  # Instead of '[ true ]', just use 'true'.
# disable=SC2161  # Instead of '[ 1 ]', use 'true'.
# disable=SC2162  # read without -r will mangle backslashes
# disable=SC2163  # This does not export 'FOO'. Remove $/${} for that, or use ${var?} to quiet.
# disable=SC2164  # Use cd ... || exit in case cd fails.
# disable=SC2165  # This nested loop overrides the index variable of its parent.
# disable=SC2166  # Prefer [ p ] && [ q ] as [ p -a q ] is not well defined.
# disable=SC2167  # This parent loop has its index variable overridden.
# disable=SC2168  # 'local' is only valid in functions.
# disable=SC2169  # In dash, *something* is not supported.
# disable=SC2170  # Numerical -eq does not dereference in [..]. Expand or use string operator.
# disable=SC2171  # Found trailing ] outside test. Add missing [ or quote if intentional.
# disable=SC2172  # Trapping signals by number is not well defined. Prefer signal names.
# disable=SC2173  # SIGKILL/SIGSTOP can not be trapped.
# disable=SC2174  # When used with -p, -m only applies to the deepest directory.
# disable=SC2175  # Quote this invalid brace expansion since it should be passed literally to eval
# disable=SC2176  # 'time' is undefined for pipelines. time single stage or bash -c instead.
# disable=SC2177  # 'time' is undefined for compound commands, time sh -c instead.
# disable=SC2178  # Variable was used as an array but is now assigned a string.
# disable=SC2179  # Use array+=("item") to append items to an array.
# disable=SC2180  # Bash does not support multidimensional arrays. Use 1D or associative arrays.
# disable=SC2181  # Check exit code directly with e.g. 'if mycmd;', not indirectly with $?.
# disable=SC2182  # This printf format string has no variables. Other arguments are ignored.
# disable=SC2183  # This format string has 2 variables, but is passed 1 arguments.
# disable=SC2184  # Quote arguments to unset so they're not glob expanded.
# disable=SC2185  # Some finds don't have a default path. Specify '.' explicitly.
# disable=SC2186  # tempfile is deprecated. Use mktemp instead.
# disable=SC2187  # Ash scripts will be checked as Dash. Add '# shellcheck shell=dash' to silence.
# disable=SC2188  # This redirection doesn't have a command. Move to its command (or use 'true' as no-op).
# disable=SC2189  # You can't have | between this redirection and the command it should apply to.
# disable=SC2190  # Elements in associative arrays need index, e.g. array=( [index]=value ) .
# disable=SC2191  # The = here is literal. To assign by index, use ( [index]=value ) with no spaces. To keep as literal, quote it.
# disable=SC2192  # This array element has no value. Remove spaces after = or use "" for empty string.
# disable=SC2193  # The arguments to this comparison can never be equal. Make sure your syntax is correct.
# disable=SC2194  # This word is constant. Did you forget the $ on a variable?
# disable=SC2195  # This pattern will never match the case statement's word. Double check them.
# disable=SC2196  # egrep is non-standard and deprecated. Use grep -E instead.
# disable=SC2197  # fgrep is non-standard and deprecated. Use grep -F instead.
# disable=SC2198  # Arrays don't work as operands in [ ]. Use a loop (or concatenate with * instead of @).
# disable=SC2199  # Arrays implicitly concatenate in `[[ ]]`. Use a loop (or explicit * instead of @).
# disable=SC2200  # Brace expansions don't work as operands in [ ]. Use a loop.
# disable=SC2201  # Brace expansion doesn't happen in `[[ ]]`. Use a loop.
# disable=SC2202  # Globs don't work as operands in [ ]. Use a loop.
# disable=SC2203  # Globs are ignored in `[[ ]]` except right of =/!=. Use a loop.
# disable=SC2204  # (..) is a subshell. Did you mean [ .. ], a test expression?
# disable=SC2205  # (..) is a subshell. Did you mean [ .. ], a test expression?
# disable=SC2206  # Quote to prevent word splitting/globbing, or split robustly with mapfile or read -a.
# disable=SC2207  # Prefer mapfile or read -a to split command output (or quote to avoid splitting).
# disable=SC2208  # Use `[[ ]]` or quote arguments to -v to avoid glob expansion.
# disable=SC2209  # Use var=$(command) to assign output (or quote to assign string).
# disable=SC2210  # This is a file redirection. Was it supposed to be a comparison or fd operation?
# disable=SC2211  # This is a glob used as a command name. Was it supposed to be in ${..}, array, or is it missing quoting?
# disable=SC2212  # Use 'false' instead of empty [/[[ conditionals.
# disable=SC2213  # getopts specified -n, but it's not handled by this 'case'.
# disable=SC2214  # This case is not specified by getopts.
# disable=SC2215  # This flag is used as a command name. Bad line break or missing `[ .. ]`?
# disable=SC2216  # Piping to 'rm', a command that doesn't read stdin. Wrong command or missing xargs?
# disable=SC2217  # Redirecting to 'echo', a command that doesn't read stdin. Bad quoting or missing xargs?
# disable=SC2218  # This function is only defined later. Move the definition up.
# disable=SC2219  # Instead of `let expr`, prefer `(( expr ))` .
# disable=SC2220  # Invalid flags are not handled. Add a `*)` case.
# disable=SC2221  # This pattern always overrides a later one.
# disable=SC2222  # This pattern never matches because of a previous pattern.
# disable=SC2223  # This default assignment may cause DoS due to globbing. Quote it.
# disable=SC2224  # This mv has no destination. Check the arguments.
# disable=SC2225  # This cp has no destination. Check the arguments.
# disable=SC2226  # This ln has no destination. Check the arguments, or specify '.' explicitly.
# disable=SC2227  # Redirection applies to the find command itself. Rewrite to work per action (or move to end).
# disable=SC2229  # This does not read 'foo'. Remove $/${} for that, or use ${var?} to quiet.
# disable=SC2230  # which is non-standard. Use builtin 'command -v' instead.
# disable=SC2231  # Quote expansions in this for loop glob to prevent wordsplitting, e.g. "$dir"/*.txt .
# disable=SC2232  # Can't use sudo with builtins like cd. Did you want sudo sh -c .. instead?
# disable=SC2233  # Remove superfluous `(..)` around condition.
# disable=SC2234  # Remove superfluous `(..)` around test command.
# disable=SC2235  # Use `{ ..; }` instead of `(..)` to avoid subshell overhead.
# disable=SC2236  # Use `-n` instead of `! -z`.
# disable=SC2237  # Use `[ -n .. ]` instead of `! [ -z .. ]`.
# disable=SC2238  # Redirecting to/from command name instead of file. Did you want pipes/xargs (or quote to ignore)?
# disable=SC2239  # Ensure the shebang uses the absolute path to the interpreter.
# disable=SC2240  # The dot command does not support arguments in sh/dash. Set them as variables.
# disable=SC2241  # The exit status can only be one integer 0-255. Use stdout for other data.
# disable=SC2242  # Can only exit with status 0-255. Other data should be written to stdout/stderr.
# disable=SC2243  # Prefer explicit -n to check for output (or run command without [/[[ to check for success)
# disable=SC2244  # Prefer explicit -n to check non-empty string (or use =/-ne to check boolean/integer).
# disable=SC2245  # -d only applies to the first expansion of this glob. Use a loop to check any/all.
# disable=SC2246  # This shebang specifies a directory. Ensure the interpreter is a file.
# disable=SC2247  # Flip leading $ and " if this should be a quoted substitution.
# disable=SC2248  # Warn about variable references without braces.
# disable=SC2249  # Consider adding a default *) case, even if it just exits with error.
disable=SC2250  # Prefer putting braces around variable references even when not strictly required.
# disable=SC2251  # This ! is not on a condition and skips errexit. Use `&& exit 1` instead, or make sure $? is checked.
# disable=SC2252  # You probably wanted && here, otherwise it's always true.
# disable=SC2253  # Use -R to recurse, or explicitly a-r to remove read permissions.
# disable=SC2254  # Quote expansions in case patterns to match literally rather than as a glob.
# disable=SC2255  # `[ ]` does not apply arithmetic evaluation. Evaluate with `$((..))` for numbers, or use string comparator for strings.
# disable=SC2256  # This translated string is the name of a variable. Flip leading $ and " if this should be a quoted substitution.
# disable=SC2257  # Arithmetic modifications in command redirections may be discarded. Do them separately.
# disable=SC2259  # This redirection overrides piped input. To use both, merge or pass filenames.
# disable=SC2260  # This redirection overrides the output pipe. Use 'tee' to output to both.
# disable=SC2261  # Multiple redirections compete for stdout. Use cat, tee, or pass filenames instead.
# disable=SC2262  # This alias can't be defined and used in the same parsing unit. Use a function instead.
disable=SC2292  # Prefer [[ ]] over [ ] for tests in Bash/Ksh.
disable=SC2312  # Consider invoking this command separately to avoid masking its return value (or use '|| true' to ignore).